{"version":3,"names":["escapeRegExp","string","replace","formatter","regExp","minusIndex","numberIndex","group","decimal","constructor","locale","options","this","Intl","NumberFormat","parts","formatToParts","part","type","value","baseFormatter","digits","Array","fill","map","_","i","format","decimalRegExp","digitRegExp","join","groupRegExp","numberRegExp","numberAdded","RegExp","number","parse","numberString","match","exec","Error","parsedString","includes","indexOf","parseFloat","resolvedOptions","static","locales","supportedLocalesOf"],"sources":["../src/helpers.js","../src/number-formatter.js"],"sourcesContent":["/**\n * Helpers\n */\n\n/**\n * Return an escaped string for use in RegEx.\n * @param {string} string The string to escape.\n * @return {string} The escaped string.\n */\nexport const escapeRegExp = (string) => string.replace(/[-/\\\\^$*+?.()|[]{}]/g, '\\\\$&');\n","import { escapeRegExp } from './helpers.js';\n\n/**\n * NumberFormatter class\n * @class\n */\nexport default class NumberFormatter {\n    #formatter;\n    #regExp;\n    #minusIndex = 1;\n    #numberIndex = 2;\n    group = '';\n    decimal = '.';\n\n    /**\n     * New NumberFormatter constructor.\n     * @param {string|string[]} [locale] The locale(s) to use for formatting.\n     * @param {object} [options] The options to use for formatting.\n     * @param {string} [options.localeMatcher] The locale matching algorithm to use.\n     * @param {string} [options.style] The formatting style to use.\n     * @param {string} [options.currency] The currency to use in currency formatting.\n     * @param {string} [options.currencyDisplay] The method for displaying currency formatting.\n     * @param {Boolean} [options.useGrouping] Whether to use grouping separators.\n     * @param {number} [options.minimumIntegerDigits] The minimum number of integer digits to use.\n     * @param {number} [options.minimumFractionDigits] The minimum number of fraction digits to use.\n     * @param {number} [options.maximumFractionDigits] The maximum number of fraction digits to use.\n     * @param {number} [options.minimumSignificantDigits] The minimum number of significant digits to use.\n     * @param {number} [options.maximumSignificantDigits] The maximum number of significant digits to use.\n     */\n    constructor(locale, options) {\n        this.#formatter = new Intl.NumberFormat(locale, options);\n\n        const parts = this.#formatter.formatToParts(-10000000.1);\n        for (const part of parts) {\n            switch (part.type) {\n                case 'group':\n                    this.group = part.value;\n                    break;\n                case 'decimal':\n                    this.decimal = part.value;\n                    break;\n            }\n        }\n\n        const baseFormatter = new Intl.NumberFormat(locale);\n\n        this.digits = new Array(10)\n            .fill()\n            .map((_, i) => baseFormatter.format(i));\n\n        const decimalRegExp = escapeRegExp(this.decimal);\n        const digitRegExp = `[${this.digits.map(escapeRegExp).join('')}]`;\n        const groupRegExp = escapeRegExp(this.group);\n\n        const numberRegExp = this.group ?\n            `(?:${digitRegExp}{1,3}${groupRegExp})*${digitRegExp}{1,3}(?:${decimalRegExp}${digitRegExp}+)?` :\n            `${digitRegExp}+(?:${decimalRegExp}${digitRegExp}+)?`;\n\n        let numberAdded = false;\n        let regExp = '';\n\n        for (const part of parts) {\n            switch (part.type) {\n                case 'literal':\n                case 'currency':\n                    regExp += `(?:${escapeRegExp(part.value)})?`;\n                    break;\n                case 'minusSign':\n                    if (numberAdded) {\n                        this.#minusIndex = 2;\n                        this.#numberIndex = 1;\n                    }\n\n                    regExp += `(${escapeRegExp(part.value)})?`;\n                    break;\n                case 'integer':\n                    if (!numberAdded) {\n                        numberAdded = true;\n\n                        regExp += `(${numberRegExp})`;\n                    }\n                    break;\n            }\n        }\n\n        this.#regExp = new RegExp(regExp);\n    }\n\n    /**\n     * Return a formatted number string, using the locale and formatting options.\n     * @param {number} number The number to format.\n     * @return {string} The formatted number string.\n     */\n    format(number) {\n        return this.#formatter.format(number);\n    }\n\n    /**\n     * Return an array of objects, containing the formatted number string in parts.\n     * @param {number} number The number to format.\n     * @return {object[]} The formatted number, as an array of parts.\n     */\n    formatToParts(number) {\n        return this.#formatter.formatToParts(number);\n    }\n\n    /**\n     * Return a parsed number from a formatted number string.\n     * @param {string} numberString The formatted number string.\n     * @return {number} The parsed number.\n     */\n    parse(numberString) {\n        const match = this.#regExp.exec(numberString);\n\n        if (!match) {\n            throw new Error('Invalid number string');\n        }\n\n        let parsedString = '';\n\n        if (match[this.#minusIndex]) {\n            parsedString += '-';\n        }\n\n        parsedString += match[this.#numberIndex].replace(\n            /./g,\n            (match) => (\n                this.digits.includes(match) ?\n                    this.digits.indexOf(match) :\n                    (\n                        match === this.decimal ?\n                            '.' :\n                            ''\n                    )\n            ),\n        );\n\n        return parseFloat(parsedString);\n    }\n\n    /**\n     * Return an object with the locale and formatting options.\n     * @return {object} The computed locale and formatting options.\n     */\n    resolvedOptions() {\n        return this.#formatter.resolvedOptions();\n    }\n\n    /**\n     * Return an array of supported locales.\n     * @param {string|string[]} locales The locale(s) to test for support.\n     * @param {object} [options] The options to use for testing support.\n     * @param {string} [options.localeMatcher] The locale matching algorithm to use.\n     * @return {string[]} An array of strings, containing matching supported locales.\n     */\n    static supportedLocalesOf(locales, options) {\n        return Intl.NumberFormat.supportedLocalesOf(locales, options);\n    }\n}\n"],"mappings":"4CASO,MAAMA,EAAgBC,GAAWA,EAAOC,QAAQ,uBAAwB,Q,OCHhE,MACXC,GACAC,GACAC,GAAc,EACdC,GAAe,EACfC,MAAQ,GACRC,QAAU,IAiBVC,YAAYC,EAAQC,GAChBC,MAAKT,EAAa,IAAIU,KAAKC,aAAaJ,EAAQC,GAEhD,MAAMI,EAAQH,MAAKT,EAAWa,eAAe,YAC7C,IAAK,MAAMC,KAAQF,EACf,OAAQE,EAAKC,MACT,IAAK,QACDN,KAAKL,MAAQU,EAAKE,MAClB,MACJ,IAAK,UACDP,KAAKJ,QAAUS,EAAKE,MAKhC,MAAMC,EAAgB,IAAIP,KAAKC,aAAaJ,GAE5CE,KAAKS,OAAS,IAAIC,MAAM,IACnBC,OACAC,KAAI,CAACC,EAAGC,IAAMN,EAAcO,OAAOD,KAExC,MAAME,EAAgB5B,EAAaY,KAAKJ,SAClCqB,EAAc,IAAIjB,KAAKS,OAAOG,IAAIxB,GAAc8B,KAAK,OACrDC,EAAc/B,EAAaY,KAAKL,OAEhCyB,EAAepB,KAAKL,MACtB,MAAMsB,SAAmBE,MAAgBF,YAAsBD,IAAgBC,OAC/E,GAAGA,QAAkBD,IAAgBC,OAEzC,IAAII,GAAc,EACd7B,EAAS,GAEb,IAAK,MAAMa,KAAQF,EACf,OAAQE,EAAKC,MACT,IAAK,UACL,IAAK,WACDd,GAAU,MAAMJ,EAAaiB,EAAKE,WAClC,MACJ,IAAK,YACGc,IACArB,MAAKP,EAAc,EACnBO,MAAKN,EAAe,GAGxBF,GAAU,IAAIJ,EAAaiB,EAAKE,WAChC,MACJ,IAAK,UACIc,IACDA,GAAc,EAEd7B,GAAU,IAAI4B,MAM9BpB,MAAKR,EAAU,IAAI8B,OAAO9B,EAClC,CAOIuB,OAAOQ,GACH,OAAOvB,MAAKT,EAAWwB,OAAOQ,EACtC,CAOInB,cAAcmB,GACV,OAAOvB,MAAKT,EAAWa,cAAcmB,EAC7C,CAOIC,MAAMC,GACF,MAAMC,EAAQ1B,MAAKR,EAAQmC,KAAKF,GAEhC,IAAKC,EACD,MAAM,IAAIE,MAAM,yBAGpB,IAAIC,EAAe,GAmBnB,OAjBIH,EAAM1B,MAAKP,KACXoC,GAAgB,KAGpBA,GAAgBH,EAAM1B,MAAKN,GAAcJ,QACrC,MACCoC,GACG1B,KAAKS,OAAOqB,SAASJ,GACjB1B,KAAKS,OAAOsB,QAAQL,GAEhBA,IAAU1B,KAAKJ,QACX,IACA,KAKboC,WAAWH,EAC1B,CAMII,kBACI,OAAOjC,MAAKT,EAAW0C,iBAC/B,CASIC,0BAA0BC,EAASpC,GAC/B,OAAOE,KAAKC,aAAakC,mBAAmBD,EAASpC,EAC7D,E"}
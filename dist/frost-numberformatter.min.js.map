{"version":3,"names":["escapeRegExp","string","replace","constructor","locale","options","this","group","decimal","_minusIndex","_numberIndex","_formatter","Intl","NumberFormat","parts","formatToParts","part","type","value","baseFormatter","digits","Array","fill","map","_","i","format","decimalRegExp","digitRegExp","join","groupRegExp","numberRegExp","numberAdded","regExp","_regExp","RegExp","number","parse","numberString","match","exec","Error","parsedString","includes","indexOf","parseFloat","resolvedOptions","supportedLocalesOf","locales"],"sources":["../src/helpers.js","../src/number-formatter.js"],"sourcesContent":["/**\n * Helpers\n */\n\n/**\n * Return an escaped string for use in RegEx.\n * @param {string} string The string to escape.\n * @return {string} The escaped string.\n */\nexport const escapeRegExp = (string) => string.replace(/[-/\\\\^$*+?.()|[]{}]/g, '\\\\$&');\n","import { escapeRegExp } from './helpers.js';\n\n/**\n * NumberFormatter class\n * @class\n */\nexport default class NumberFormatter {\n    /**\n     * New NumberFormatter constructor.\n     * @param {string|string[]} [locale] The locale(s) to use for formatting.\n     * @param {object} [options] The options to use for formatting.\n     * @param {string} [options.localeMatcher] The locale matching algorithm to use.\n     * @param {string} [options.style] The formatting style to use.\n     * @param {string} [options.currency] The currency to use in currency formatting.\n     * @param {string} [options.currencyDisplay] The method for displaying currency formatting.\n     * @param {Boolean} [options.useGrouping] Whether to use grouping separators.\n     * @param {number} [options.minimumIntegerDigits] The minimum number of integer digits to use.\n     * @param {number} [options.minimumFractionDigits] The minimum number of fraction digits to use.\n     * @param {number} [options.maximumFractionDigits] The maximum number of fraction digits to use.\n     * @param {number} [options.minimumSignificantDigits] The minimum number of significant digits to use.\n     * @param {number} [options.maximumSignificantDigits] The maximum number of significant digits to use.\n     */\n    constructor(locale, options) {\n        this.group = '';\n        this.decimal = '.';\n        this._minusIndex = 1;\n        this._numberIndex = 2;\n\n        this._formatter = new Intl.NumberFormat(locale, options);\n\n        const parts = this._formatter.formatToParts(-10000000.1);\n        for (const part of parts) {\n            switch (part.type) {\n                case 'group':\n                    this.group = part.value;\n                    break;\n                case 'decimal':\n                    this.decimal = part.value;\n                    break;\n            }\n        }\n\n        const baseFormatter = new Intl.NumberFormat(locale);\n\n        this.digits = new Array(10)\n            .fill()\n            .map((_, i) => baseFormatter.format(i));\n\n        const decimalRegExp = escapeRegExp(this.decimal);\n        const digitRegExp = `[${this.digits.map(escapeRegExp).join('')}]`;\n        const groupRegExp = escapeRegExp(this.group);\n\n        const numberRegExp = this.group ?\n            `(?:${digitRegExp}{1,3}${groupRegExp})*${digitRegExp}{1,3}(?:${decimalRegExp}${digitRegExp}+)?` :\n            `${digitRegExp}+(?:${decimalRegExp}${digitRegExp}+)?`;\n\n        let numberAdded = false;\n        let regExp = '';\n\n        for (const part of parts) {\n            switch (part.type) {\n                case 'literal':\n                case 'currency':\n                    regExp += `(?:${escapeRegExp(part.value)})?`;\n                    break;\n                case 'minusSign':\n                    if (numberAdded) {\n                        this._minusIndex = 2;\n                        this._numberIndex = 1;\n                    }\n\n                    regExp += `(${escapeRegExp(part.value)})?`;\n                    break;\n                case 'integer':\n                    if (!numberAdded) {\n                        numberAdded = true;\n\n                        regExp += `(${numberRegExp})`;\n                    }\n                    break;\n            }\n        }\n\n        this._regExp = new RegExp(regExp);\n    }\n\n    /**\n     * Return a formatted number string, using the locale and formatting options.\n     * @param {number} number The number to format.\n     * @return {string} The formatted number string.\n     */\n    format(number) {\n        return this._formatter.format(number);\n    }\n\n    /**\n     * Return an array of objects, containing the formatted number string in parts.\n     * @param {number} number The number to format.\n     * @return {object[]} The formatted number, as an array of parts.\n     */\n    formatToParts(number) {\n        return this._formatter.formatToParts(number);\n    }\n\n    /**\n     * Return a parsed number from a formatted number string.\n     * @param {string} numberString The formatted number string.\n     * @return {number} The parsed number.\n     */\n    parse(numberString) {\n        const match = this._regExp.exec(numberString);\n\n        if (!match) {\n            throw new Error('Invalid number string');\n        }\n\n        let parsedString = '';\n\n        if (match[this._minusIndex]) {\n            parsedString += '-';\n        }\n\n        parsedString += match[this._numberIndex].replace(\n            /./g,\n            (match) => (\n                this.digits.includes(match) ?\n                    this.digits.indexOf(match) :\n                    (\n                        match === this.decimal ?\n                            '.' :\n                            ''\n                    )\n            ),\n        );\n\n        return parseFloat(parsedString);\n    }\n\n    /**\n     * Return an object with the locale and formatting options.\n     * @return {object} The computed locale and formatting options.\n     */\n    resolvedOptions() {\n        return this._formatter.resolvedOptions();\n    }\n\n    /**\n     * Return an array of supported locales.\n     * @param {string|string[]} locales The locale(s) to test for support.\n     * @param {object} [options] The options to use for testing support.\n     * @param {string} [options.localeMatcher] The locale matching algorithm to use.\n     * @return {string[]} An array of strings, containing matching supported locales.\n     */\n    static supportedLocalesOf(locales, options) {\n        return Intl.NumberFormat.supportedLocalesOf(locales, options);\n    }\n}\n"],"mappings":"gPASO,MAAMA,EAAgBC,GAAWA,EAAOC,QAAQ,uBAAwB,Q,OCHhE,MAgBX,WAAAC,CAAYC,EAAQC,GAChBC,KAAKC,MAAQ,GACbD,KAAKE,QAAU,IACfF,KAAKG,YAAc,EACnBH,KAAKI,aAAe,EAEpBJ,KAAKK,WAAa,IAAIC,KAAKC,aAAaT,EAAQC,GAEhD,MAAMS,EAAQR,KAAKK,WAAWI,eAAe,YAC7C,IAAK,MAAMC,KAAQF,EACf,OAAQE,EAAKC,MACT,IAAK,QACDX,KAAKC,MAAQS,EAAKE,MAClB,MACJ,IAAK,UACDZ,KAAKE,QAAUQ,EAAKE,MAKhC,MAAMC,EAAgB,IAAIP,KAAKC,aAAaT,GAE5CE,KAAKc,OAAS,IAAIC,MAAM,IACnBC,OACAC,KAAI,CAACC,EAAGC,IAAMN,EAAcO,OAAOD,KAExC,MAAME,EAAgB3B,EAAaM,KAAKE,SAClCoB,EAAc,IAAItB,KAAKc,OAAOG,IAAIvB,GAAc6B,KAAK,OACrDC,EAAc9B,EAAaM,KAAKC,OAEhCwB,EAAezB,KAAKC,MACtB,MAAMqB,SAAmBE,MAAgBF,YAAsBD,IAAgBC,OAC/E,GAAGA,QAAkBD,IAAgBC,OAEzC,IAAII,GAAc,EACdC,EAAS,GAEb,IAAK,MAAMjB,KAAQF,EACf,OAAQE,EAAKC,MACT,IAAK,UACL,IAAK,WACDgB,GAAU,MAAMjC,EAAagB,EAAKE,WAClC,MACJ,IAAK,YACGc,IACA1B,KAAKG,YAAc,EACnBH,KAAKI,aAAe,GAGxBuB,GAAU,IAAIjC,EAAagB,EAAKE,WAChC,MACJ,IAAK,UACIc,IACDA,GAAc,EAEdC,GAAU,IAAIF,MAM9BzB,KAAK4B,QAAU,IAAIC,OAAOF,EAClC,CAOI,MAAAP,CAAOU,GACH,OAAO9B,KAAKK,WAAWe,OAAOU,EACtC,CAOI,aAAArB,CAAcqB,GACV,OAAO9B,KAAKK,WAAWI,cAAcqB,EAC7C,CAOI,KAAAC,CAAMC,GACF,MAAMC,EAAQjC,KAAK4B,QAAQM,KAAKF,GAEhC,IAAKC,EACD,MAAM,IAAIE,MAAM,yBAGpB,IAAIC,EAAe,GAmBnB,OAjBIH,EAAMjC,KAAKG,eACXiC,GAAgB,KAGpBA,GAAgBH,EAAMjC,KAAKI,cAAcR,QACrC,MACCqC,GACGjC,KAAKc,OAAOuB,SAASJ,GACjBjC,KAAKc,OAAOwB,QAAQL,GAEhBA,IAAUjC,KAAKE,QACX,IACA,KAKbqC,WAAWH,EAC1B,CAMI,eAAAI,GACI,OAAOxC,KAAKK,WAAWmC,iBAC/B,CASI,yBAAOC,CAAmBC,EAAS3C,GAC/B,OAAOO,KAAKC,aAAakC,mBAAmBC,EAAS3C,EAC7D,E"}